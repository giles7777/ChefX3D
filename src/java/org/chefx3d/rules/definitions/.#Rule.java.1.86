/*****************************************************************************
 *                        Copyright Yumetech, Inc (c) 2006 - 2009
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package org.chefx3d.rules.definitions;

//External Imports
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.prefs.Preferences;

import javax.vecmath.AxisAngle4f;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;

import org.j3d.util.I18nManager;

//Internal Imports
import org.chefx3d.catalog.CatalogManager;
import org.chefx3d.model.AddEntityChildCommand;
import org.chefx3d.model.AddEntityChildTransientCommand;
import org.chefx3d.model.BasePositionableEntity;
import org.chefx3d.model.Command;
import org.chefx3d.model.Entity;
import org.chefx3d.model.MoveEntityCommand;
import org.chefx3d.model.ScaleEntityCommand;
import org.chefx3d.model.PositionableEntity;
import org.chefx3d.model.RuleDataAccessor;
import org.chefx3d.model.SegmentEntity;
import org.chefx3d.model.VertexEntity;
import org.chefx3d.model.WorldModel;
import org.chefx3d.model.ZoneEntity;
import org.chefx3d.rules.properties.ChefX3DRuleProperties;
import org.chefx3d.tool.SimpleTool;
import org.chefx3d.ui.PopUpConfirm;
import org.chefx3d.ui.PopUpMessage;
import org.chefx3d.ui.StatusBar;
import org.chefx3d.util.ErrorReporter;
import org.chefx3d.view.awt.av3d.AV3DView;
import org.chefx3d.view.awt.av3d.NearestNeighborMeasurement;
import org.chefx3d.view.awt.av3d.RuleCollisionChecker;
import org.chefx3d.view.awt.av3d.TransformUtils;
import org.chefx3d.util.ApplicationParams;

/**
 * Abstract definition for Rule. Rule specifies a single rule and the processes
 * that make up the rule. A Rule returns a boolean response about the condition
 * that determines if a Command can be executed or must be rejected and
 * possibly results in an automatically handled response in the environment.
 *
 * Also contains utility functions for all rule classes.
 *
 * @author Ben Yarger
 * @version $Revision: 1.86 $
 */
public abstract class Rule {

    /** Error message for class cast exceptions */
    private static final String CLASS_CAST_EXCEPTION_MSG =
        "Rule: sortDescendingPosValueOrder class cast exception.";

    /** Constant threshold value used in angle calculations */
    private static double ANGLE_CHECK_THRESHOLD = 0.0001;

    /** Constant threshold value used to calculate THRESHOLD */
    private static final double INIT_THRESHOLD = 0.25;

    /** Auto-span Overlap threshold */
    public static final float SPAN_OVERLAP_THRESHOLD = 0.004f;

    /** Command list built up during rule engine execution */
    private static ArrayList<Command> newlyIssuedCommands =
        new ArrayList<Command>();

    /** Accessor to catalog lookup */
    protected CatalogManager catalogManager = CatalogManager.getCatalogManager();

    /** Error reporting utility */
    protected ErrorReporter errorReporter;

    /** Collision checking instance */
    protected RuleCollisionChecker collisionChecker;

    /** AV3DView instance */
    protected AV3DView view;

    /** StatusBar messenger */
    protected StatusBar statusBar = StatusBar.getStatusBar();

    /** Displays a pop up message */
    protected PopUpMessage popUpMessage = PopUpMessage.getInstance();

    /** Displays a pop up confirm message */
    protected PopUpConfirm popUpConfirm = PopUpConfirm.getInstance();

    /** Translation utility */
    protected I18nManager intl_mgr = I18nManager.getManager();

    /** Enumerated rule types */
    public static enum RULE_TYPE {INVIOLABLE, STANDARD, INFORMATIONAL};

    /** The type of the rule implementation */
    protected RULE_TYPE ruleType;

    /** The current entity collisions shared between implementing rules */
    protected static ArrayList<Entity> collisionEntities;

    /** The current entity-children collisions shared between implementing rules */
    protected static Map<Entity,ArrayList<Entity>> collisionEntitiesMap;

    /** Break out of model entities matching relationship requirements */
    protected static ArrayList<Entity> entityMatches = new ArrayList<Entity>();

    /** Break out of zone collision entities */
    protected static ArrayList<Entity> zoneEntityMatches = new ArrayList<Entity>();

    /** Break out of wall collision entities */
    protected static ArrayList<Entity> wallEntityMatches = new ArrayList<Entity>();

    /** Break out of entities to replace based on REPLACE_PROD_CLASS_PROP */
    protected static ArrayList<Entity> replaceEntityMatches = new ArrayList<Entity>();

    /** Break out of illegal entities */
    protected static ArrayList<Entity> illegalEntities = new ArrayList<Entity>();

    /** Map of classifications to number of occurrences */
    protected static HashMap<String, Integer> entityMatchCountMap = new HashMap<String, Integer>();

    /** Map of classifications to number of occurrences */
    protected static HashMap<String, Integer> zoneMatchCountMap = new HashMap<String, Integer>();

    /** Map of classifications to number of occurrences */
    protected static HashMap<String, Integer> wallMatchCountMap = new HashMap<String, Integer>();


    private class ChildrenMatches{

        /** Break out of model entities matching relationship requirements */
        private  ArrayList<Entity> entityMatches = new ArrayList<Entity>();

        /** Break out of zone collision entities */
        private  ArrayList<Entity> zoneEntityMatches = new ArrayList<Entity>();

        /** Break out of wall collision entities */
        private  ArrayList<Entity> wallEntityMatches = new ArrayList<Entity>();

        /** Break out of entities to replace based on REPLACE_PROD_CLASS_PROP */
        private  ArrayList<Entity> replaceEntityMatches = new ArrayList<Entity>();

        /** Break out of illegal entities */
        private  ArrayList<Entity> illegalEntities = new ArrayList<Entity>();

        /** Map of classifications to number of occurrences */
        private  HashMap<String, Integer> entityMatchCountMap = new HashMap<String, Integer>();

        /** Map of classifications to number of occurrences */
        private  HashMap<String, Integer> zoneMatchCountMap = new HashMap<String, Integer>();

        /** Map of classifications to number of occurrences */
        private  HashMap<String, Integer> wallMatchCountMap = new HashMap<String, Integer>();
    }

    protected Map<Entity,ChildrenMatches > matchesMap;

    /** NearesetNeighborMeasurement instance */
    protected static NearestNeighborMeasurement nearestNeighbor;

    //---------------------------------------------------------------
    // Rule processing entry point
    //---------------------------------------------------------------

    /**
     * All instances of Rule should call processRule with the
     * Command and transient state to convert and process.
     * Convert expects the Command to
     * implement RuleDataAccessor. If it doesn't it returns true and
     * logs a note to the console.
     *
     * @param command Command that needs to be converted
     * @param errorReporter Error reporting object
     * @param collisionChecker RuleCollisionChecker to use for collisions
     * @param view AV3DView instance
     * @return true if command can continue, false otherwise
     */
    public boolean processRule(
            Command command,
            ErrorReporter errorReporter,
            RuleCollisionChecker collisionCheck,
            AV3DView view) {

        /*
         * Perform rule override analysis.
         * Return true if overriding standard rules.
         */
        String appName = (String) ApplicationParams.get(
                ApplicationParams.APP_NAME);


        // check here for class names and such
        Class currentClass = this.getClass();

        ArrayList<String> ignoreList = command.getIgnoreRuleList();
        if(ignoreList != null) {
           if(ignoreList.contains(currentClass.getName())) {
               return true;
           }
        }

        Preferences prefs = Preferences.userRoot().node(appName);
        Boolean ruleOverride = prefs.getBoolean("overrideRules", false);

        if(ruleType != null &&
                ruleType == RULE_TYPE.STANDARD &&
                ruleOverride == true){

            return true;
        }

        // Continue with execution of the rule
        this.errorReporter = errorReporter;
        this.collisionChecker = collisionCheck;
        this.view = view;

        if(nearestNeighbor == null){

            nearestNeighbor =
                new NearestNeighborMeasurement(view.getWrapperMap());

        } else {

            nearestNeighbor.updateWrapperMap(view.getWrapperMap());
        }

        if(command instanceof RuleDataAccessor){

            RuleDataAccessor dataAccessor = (RuleDataAccessor)command;

            Entity entity = dataAccessor.getEntity();
            WorldModel model = dataAccessor.getWorldModel();

            // Attempted catch to pevent NPE described in bugs 97 & 42 (BJY)
            if(entity == null){

                errorReporter.debugReport("Rule found command entity was null. Command description: "+command.getDescription(), null);
                return false;
            }

            return performCheck(entity, model, command);

        } else {

            System.out.println("CommandToRuleAdapter did not receive an object of type RuleDataAccessor.");
            return true;
        }
    }


    //-------------------------------------------------------------------------
    // Abstract method definitions
    //-------------------------------------------------------------------------

    /**
     * Abstract definition of performCheck which plucks apart the Entity and
     * WorldModel for the data expected by the rule the adapter communicates
     * with.
     *
     * @param entity Entity object
     * @param model WorldModel object
     * @param command Command object
     * @return boolean true if rule checks out, false otherwise
     */
    protected abstract boolean performCheck(
            Entity entity,
            WorldModel model,
            Command command);

    //-------------------------------------------------------------------------
    // Public methods
    //-------------------------------------------------------------------------

    /**
     * Get the local bounds of this entity.  This takes the
     * current size and offset and uses the new scale to calculate
     * the bounds that would result by the request
     *
     * @param entity The entity being processed
     * @param scale The new scale being requested
     * @param bounds a float array of length six to hold the
     * local bounds of this entity.
     */
    public void calculateBounds(
            PositionableEntity entity,
            float[] scale,
            float[] bounds){
        float[] size = new float[3];
        double[] originOffset = new double[3];

        entity.getSize(size);
        entity.getOriginOffset(originOffset);

        float halfXWidth = (size[0]*scale[0])/2f;
        float halfYWidth = (size[1]*scale[1])/2f;
        float halfZWidth = (size[2]*scale[2])/2f;

        bounds[0] = -halfXWidth + (float)originOffset[0];
        bounds[1] = halfXWidth + (float)originOffset[0];
        bounds[2] = -halfYWidth + (float)originOffset[1];
        bounds[3] = halfYWidth + (float)originOffset[1];
        bounds[4] = -halfZWidth + (float)originOffset[2];
        bounds[5] = halfZWidth + (float)originOffset[2];
    }

    /**
     * Clear the newlyIssuedCommands ArrayList.
     */
    public static void clearNewlyIssuedCommands(){

        newlyIssuedCommands.clear();
    }

    /**
     * Get the newlyIssuedCommands ArrayList
     *
     * @return ArrayList<Command>
     */
    public static ArrayList<Command> getNewlyIssuedCommands(){

        return newlyIssuedCommands;
    }

    /**
     * Get the size of the newlyIssuedCommands ArrayList
     * @return size of list
     */
    public static int newlyIssuedCommandSize(){

        return newlyIssuedCommands.size();
    }

    /**
     * See if there are newly issued commands
     * @return True if new commands exist, false otherwise
     */
    public static boolean hasNewlyIssuedCommands(){

        if(newlyIssuedCommandSize() > 0){
            return true;
        }

        return false;
    }

    /**
     * Finds the closest snap value for the original value.
     *
     * @param originalValue Original axis value
     * @param snaps Associated array of same axis snap values to compare with
     * @return double replacement value for the original
     */
    public static double findClosestValue(double originalValue, float[] snaps){

        Arrays.sort(snaps);
        double newValue = snaps[0];

        /*
         * start from the beginning of the ordered snap values and see at what
         * point the original value is less than the snap the snap.
         */
        for(int i = 1; i < snaps.length; i++){

             if(originalValue > ((snaps[i] - snaps[i-1])/2.0f + snaps[i-1])){

                 newValue = snaps[i];
             } else {
                 break;
             }
        }

        return newValue;
    }

    /**
     * Calculate the zoom threshold for tolerance calculations. Zoom factor
     * will return an acceptable offset of .25 m for a distance of 10 units
     * between the zoom position and the active zone. The thresholdConst
     * can be used to implement a fixed threshold value in addition to the
     * calculated value so that a standard result of 0.0 would return whatever
     * the thresholdConst is set to and a result of 0.25 would return
     * 0.25 + thresholdConst.
     *
     * @param view Active AV3DView to get zoom value for
     * @param thresholdConst Specific threshold constant to add, can be null
     * @return threshold value
     */
    public static double getZoomThreshold(AV3DView view, Double thresholdConst){

        double zoom = view.getZoneViewZoomAmount();

        if(thresholdConst != null){

            if (thresholdConst > 1.0) {
                thresholdConst = 1.0;
            } else if (thresholdConst < 0) {
                thresholdConst = 0.0;
            }

        } else {
            thresholdConst = 0.0;
        }

        double resultThreshold = zoom / 10.0 * INIT_THRESHOLD + thresholdConst;

        return resultThreshold;
    }


    //-------------------------------------------------------------------------
    // Protected methods
    //-------------------------------------------------------------------------

    /**
     * Perform collision check on command
     */
    protected void performCollisionCheck(Command command){

        // Make sure we have an EntityCollisionManager
        if(collisionChecker == null){

            errorReporter.fatalErrorReport(
                    "Unable to access the collision detection system from the rules.",
                    null);
        }

        // make sure we have an entity
        Entity entity = ((RuleDataAccessor)command).getEntity();
        if (entity == null) {
            collisionEntities = null;
            return;
        }

        // Get the collision results
        String url_string = entity.getModelURL();

        if(url_string != null){
            collisionEntities = collisionChecker.submitCommand(command);
        } else {
            collisionEntities = null;
            return;
        }

        // Perform the forced parent entity addition to the collision set if
        // 1) Entity is now in a placement mode
        // 2) PARENT_AS_COLLISION_ALTERNATE is true
        // 3) the collision set doesn't already contain the entity
        if(command instanceof RuleDataAccessor){

            WorldModel model = ((RuleDataAccessor)command).getWorldModel();

            Boolean forceParentCollision =
                (Boolean) entity.getProperty(
                        Entity.DEFAULT_ENTITY_PROPERTIES,
                        ChefX3DRuleProperties.PARENT_AS_COLLISION_ALTERNATE);

            /*
             * If shadow entity, don't bother with this check.
             */
            Boolean isShadow =
                (Boolean)entity.getProperty(
                        entity.getParamSheetName(),
                        Entity.SHADOW_ENTITY_FLAG);

            if (isShadow != null && isShadow == true) {
                return;
            }

            if(forceParentCollision != null && forceParentCollision == true){

                int parentEntityID = entity.getParentEntityID();

                Entity parentEntity = model.getEntity(parentEntityID);

                // Need to handle add command sepecial cases
                if(command instanceof AddEntityChildCommand){

                    parentEntity =
                        ((AddEntityChildCommand)command).getParentEntity();

                } else if (command instanceof AddEntityChildTransientCommand){

                    parentEntity =
                        ((AddEntityChildTransientCommand)command).
                        getParentEntity();

                }

                // Never add a null entity to the collision list
                if(parentEntity == null) {
                    return;
                }

                // Never add a segment or zone to the collision list
                if(parentEntity.getType() != Entity.TYPE_MODEL) {
                    return;
                }

                for(int i = 0; i < collisionEntities.size(); i++) {

                    if(collisionEntities.get(i).getEntityID() ==
                        parentEntity.getEntityID()){

                        // Exit and don't bother adding because it is already
                        // in the collision set.
                        return;
                    }
                }

                collisionEntities.add(parentEntity);
            }
        }
    }

    /**
    * Perform collision check on command
    */
   protected void performExtendedCollisionCheck(Command command){

       // Make sure we have an EntityCollisionManager
       if(collisionChecker == null){

           errorReporter.fatalErrorReport(
                   "Unable to access the collision detection system from the rules.",
                   null);
       }

       // Get the collision results
       String url_string =
           ((RuleDataAccessor)command).getEntity().getModelURL();

       if(url_string != null){
           collisionEntitiesMap = collisionChecker.submitCommandExtended(command);
       } else {
           collisionEntitiesMap = null;
       }
   }


    /**
     * Collision check used by add commands that results in a
     * re-parenting action in order to guarantee collision results.
     * Typically used by auto place actions.
     *
     * @param model WorldModel
     * @param parentEntityParentEntity Parent entity's parent
     * @param parentEntity Entity's parent Entity
     * @param entity Entity that started this whole mess.
     */
    protected void performSpecialAddCollisionCheck(
            WorldModel model,
            Entity parentEntityParentEntity,
            Entity parentEntity,
            Entity entity){

        /*
         * Extract and save the original parent entity id and position of the
         * entity to add back at the end.
         */
        int originalEntityParentID = entity.getParentEntityID();
        double[] relPosition = new double[3];
        double[] parentPos = new double[3];

        ((PositionableEntity)entity).getPosition(relPosition);
        ((PositionableEntity)parentEntity).getPosition(parentPos);

        parentPos[0] = parentPos[0] + relPosition[0];
        parentPos[1] = parentPos[1] + relPosition[1];
        parentPos[2] = parentPos[2] + relPosition[2];

        float[] eBounds = new float[6];
        ((PositionableEntity)entity).getBounds(eBounds);

        entity.setParentEntityID(parentEntityParentEntity.getEntityID());
        ((PositionableEntity)entity).setPosition(parentPos, false);

        AddEntityChildCommand addChildCmd =
            new AddEntityChildCommand(model, parentEntityParentEntity, entity);

        performCollisionCheck(addChildCmd);

        /*
         * Reset the original parent id and position.
         */
        entity.setParentEntityID(originalEntityParentID);
        ((PositionableEntity)entity).setPosition(relPosition, false);
    }

    /**
     * Shortcut helper for most typical collision analysis checks.
     *
     * @param entity Entity to extract requisite data from
     * @param ghostEntities Ghost entities not yet in the scene to consider
     * @param ignoreSameClass Ignore collision objects with same classification
     * @param ignoreEntityIdList List of entity id's to ignore in collision set
     * @param ignoreChildren Flags if the children should be ignored
     * @return True if succeeded, false if there was a problem extracting data
     */
    protected boolean performCollisionAnalysisHelper(
            Entity entity,
            Entity[] ghostEntities,
            boolean ignoreSameClass,
            int[] ignoreEntityIdList,
            boolean ignoreChildren){

        String[] classifications = (String[]) entity.getProperty(
                Entity.DEFAULT_ENTITY_PROPERTIES,
                ChefX3DRuleProperties.CLASSIFICATION_PROP);

        String[] classRelationship = (String[]) entity.getProperty(
                Entity.DEFAULT_ENTITY_PROPERTIES,
                ChefX3DRuleProperties.RELATIONSHIP_CLASSIFICATION_PROP);

        int[] relationshipAmount = (int[]) entity.getProperty(
                Entity.DEFAULT_ENTITY_PROPERTIES,
                ChefX3DRuleProperties.RELATIONSHIP_AMOUNT_PROP);

        Enum[] relModifier =
            (Enum[])
            entity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_PROP);

        String[] colReplaceClass = (String[]) entity.getProperty(
                Entity.DEFAULT_ENTITY_PROPERTIES,
                ChefX3DRuleProperties.REPLACE_PROD_CLASS_PROP);

        if(classRelationship == null ||
                relationshipAmount == null ||
                relModifier == null){

            return false;
        }

        ArrayList<Entity> childrenToIgnore = new ArrayList<Entity>();

        if (ignoreChildren) {
            childrenToIgnore = entity.getChildren();
        }

        int maxIndex = Math.min(
                (Math.min(
                        classRelationship.length,
                        relationshipAmount.length)),
                relModifier.length);

        return performCollisionAnalysis(
                classRelationship,
                classifications,
                childrenToIgnore,
                colReplaceClass,
                maxIndex,
                ghostEntities,
                ignoreSameClass,
                ignoreEntityIdList);
    }

    /**
     * Shortcut helper for most typical collision analysis checks for children.
     *
     * @param entity Entity to extract requisite data from
     * @param ghostEntities Ghost entities not yet in the scene to consider
     * @param ignoreSameClass Ignore collision objects with same classification
     * @param ignoreEntityIdList List of entity id's to ignore in collision set
     * @return True if succeeded, false if there was a problem extracting data
     */
    protected boolean performExtendedCollisionAnalysisHelper(
            Entity[] ghostEntities,
            boolean ignoreSameClass,
            int[] ignoreEntityIdList){

        if(collisionEntitiesMap == null ||
                collisionEntitiesMap.isEmpty())
            return false;

        Object[] keyArray= collisionEntitiesMap.keySet().toArray();

        for(int i = 0 ; i<keyArray.length;i++) {

            Entity currentEntity = (Entity)keyArray[i];

            String[] classifications = (String[]) currentEntity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.CLASSIFICATION_PROP);

            String[] classRelationship = (String[]) currentEntity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.RELATIONSHIP_CLASSIFICATION_PROP);

            int[] relationshipAmount = (int[]) currentEntity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.RELATIONSHIP_AMOUNT_PROP);

            Enum[] relModifier =
                (Enum[])
                currentEntity.getProperty(
                        Entity.DEFAULT_ENTITY_PROPERTIES,
                        ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_PROP);

            String[] colReplaceClass = (String[]) currentEntity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.REPLACE_PROD_CLASS_PROP);


            if(classRelationship == null ||
                    relationshipAmount == null ||
                    relModifier == null){

                return false;
            }

            int maxIndex = Math.min(
                    (Math.min(
                            classRelationship.length,
                            relationshipAmount.length)),
                    relModifier.length);


            if(matchesMap == null)
                matchesMap = new HashMap<Entity,ChildrenMatches>();

            ChildrenMatches match = new ChildrenMatches();
            performExtendedCollisionAnalysis(
                    collisionEntitiesMap.get(currentEntity),
                    match,
                    classRelationship,
                    classifications,
                    currentEntity.getChildren(),
                    colReplaceClass,
                    maxIndex,
                    ghostEntities,
                    ignoreSameClass,
                    ignoreEntityIdList);
            this.matchesMap.put(currentEntity, match);

        }

        return false;



    }


    /**
     * Begin collision results analysis:
     *
     * Separate collisions into the following types:
     * TYPE_MODEL       (classification relationship matching only)
     * TYPE_ZONE        (floor)
     * TYPE_SEGMENT     (wall)
     *
     * @param classRelationship String[] of relationship names of current entity
     * @param classification String[] of classification names of current entity - used only if ignoreSameClass is true
     * @param childrenToIgnore ArrayList<Entity> children to remove from collision list
     * @param classificationToReplace String[] of classifications to replace
     * @param maxIndex Number of classRelationship indexes to check
     * @param vaporEntities Entity[] entities not yet in the scene to consider
     * @param ignoreSameClass If true collision objects with same
     * classification will be ignored
     * @param ignoreEntityIdList list of entity id's to ignore
     * @return True if ok, false if couldn't match valid collisions to categories
     */
    protected boolean performCollisionAnalysis(
            String[] classRelationship,
            String[] classification,
            ArrayList<Entity> childrenToIgnore,
            String[] classificationToReplace,
            int maxIndex,
            Entity[] vaporEntities,
            boolean ignoreSameClass,
            int[] ignoreEntityIdList){

        entityMatches = new ArrayList<Entity>();
        zoneEntityMatches = new ArrayList<Entity>();
        wallEntityMatches = new ArrayList<Entity>();
        replaceEntityMatches = new ArrayList<Entity>();
        illegalEntities = new ArrayList<Entity>();
        entityMatchCountMap = new HashMap<String, Integer>();
        zoneMatchCountMap = new HashMap<String, Integer>();
        wallMatchCountMap = new HashMap<String, Integer>();

        // If nothing to compare, stop analysis
        if(classRelationship == null){
            return true;
        }

        /*
         * Add entities to the collision list that otherwise would never
         * be picked up in a collision case. Allows forced compliance
         * with collision requirements.
         */
        if(vaporEntities != null){

            if(collisionEntities == null){
                collisionEntities = new ArrayList<Entity>();
            }

            for(int i = 0; i < vaporEntities.length; i++){

                if(!collisionEntities.contains(vaporEntities[i])){
                    collisionEntities.add(vaporEntities[i]);
                }
            }
        }

        if(collisionEntities == null){
            return true;
        }

        // Remove specific entities from the collision list
        if(ignoreEntityIdList != null){

            for(int i = 0; i < ignoreEntityIdList.length; i++){

                for(int j = collisionEntities.size() - 1; j >= 0; j--){

                    if(collisionEntities.get(j).getEntityID() ==
                        ignoreEntityIdList[i]){

                        collisionEntities.remove(j);
                    }
                }
            }
        }

        /*
         * Remove children from collision entities list
         */
        if(childrenToIgnore != null){
            for(int i = 0; i < childrenToIgnore.size(); i++){

                if(collisionEntities.contains(childrenToIgnore.get(i))){

                    collisionEntities.remove(childrenToIgnore.get(i));
                }
            }
        }

        /*
         * Loop through all of the entities in collision with moving entity.
         * Look for class relationships to define legal collisions and
         * build up the map of relationship names to entities.
         */
        ArrayList<String> collisionClassificationList = new ArrayList<String>();
        ArrayList<Entity> collisionEntityList = new ArrayList<Entity>();

        for(int w = collisionEntities.size() - 1; w >= 0; w--){

            Entity entityObj = collisionEntities.get(w);

            String[] colObjClass = (String[]) entityObj.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.CLASSIFICATION_PROP);

            if(colObjClass != null){

                /*
                 * Extract children from collision entities that
                 * would be replaced by entity.
                 */
                if(classificationToReplace != null){

                    boolean classMatchFound = false;

                    for(int i = 0; i < classificationToReplace.length; i++){

                        for(int j = 0; j < colObjClass.length; j++){

                            if(classificationToReplace[i].equals(
                                    colObjClass[j])){

                                addReplaceMatch(entityObj);
                                collisionEntities.remove(w);
                                classMatchFound = true;
                                break;
                            }
                        }

                        if(classMatchFound){
                            break;
                        }
                    }

                    if(classMatchFound){
                        continue;
                    }
                }

                /*
                 * If ignoreSameClass is set, look for same classification
                 * name and if found skip evaluation for that index, and
                 * remove the entity from the collisionEntities list.
                 */
                if(ignoreSameClass && classification != null){

                    boolean classMatchFound = false;

                    for(int i = 0; i < colObjClass.length; i++){

                        for(int j = 0; j < classification.length; j++){

                            if(colObjClass[i].equals(classification[j])){
                                 classMatchFound = true;
                                 collisionEntities.remove(w);
                                 break;
                            }
                        }

                        if(classMatchFound){
                            break;
                        }
                    }

                    if(classMatchFound){
                        continue;
                    }
                }

                for(int i = 0; i < colObjClass.length; i++){

                    collisionClassificationList.add(colObjClass[i]);
                    collisionEntityList.add(entityObj);
                }
            }
        }

        /*
         * Make sure collision matches a relationship classification type.
         * If the classRelationship contains the : character, tokenize the
         * string and examine each part for a match. Either way, check
         * matches for the entity type and assign to the correct list.
         */
        for(int i = 0; i < maxIndex; i++){

            illegalEntities.clear();

            // Check for : character
            if(classRelationship[i].contains(":")){

                // For proper analysis we cannot have multiple entries with
                // the same name in a relClass so clean it
                HashMap<String, Integer> cleanedClassRelationship =
                    cleanClassRelationship(classRelationship[i]);

                Object[] keys =
                    cleanedClassRelationship.keySet().toArray();

                String token;

                for (int x = 0; x < keys.length; x++) {

                    token = (String) keys[x];

                    for(int w = 0; w < collisionClassificationList.size(); w++){

                        String colClass = collisionClassificationList.get(w);

                        if(colClass.equals(token)){

                            Entity entityObj = collisionEntityList.get(w);

                            if(entityObj.getType() == Entity.TYPE_MODEL){

                                addModelMatch(entityObj, colClass);
                            } else if (entityObj.getType() == Entity.TYPE_ZONE){

                                addZoneMatch(entityObj, colClass);

                            } else if (entityObj.getType() == Entity.TYPE_SEGMENT) {

                                addSegmentMatch(entityObj, colClass);

                            }
                        }
                    }
                }

            } else {

                for(int w = 0; w < collisionClassificationList.size(); w++){

                    String colClass = collisionClassificationList.get(w);

                    if(colClass.equals(classRelationship[i])){

                        Entity entityObj = collisionEntityList.get(w);

                        if(entityObj.getType() == Entity.TYPE_MODEL){

                            addModelMatch(entityObj, colClass);

                        } else if (entityObj.getType() == Entity.TYPE_ZONE){

                            addZoneMatch(entityObj, colClass);

                        } else if (entityObj.getType() == Entity.TYPE_SEGMENT) {

                            addSegmentMatch(entityObj, colClass);

                        }
                    }
                }
            }

            int validMatches =
                entityMatches.size() +
                zoneEntityMatches.size() +
                wallEntityMatches.size();

            if (validMatches != collisionEntities.size()){

                try{
                    illegalEntities.addAll(collisionEntities);

                    illegalEntities.removeAll(entityMatches);
                    illegalEntities.removeAll(zoneEntityMatches);
                    illegalEntities.removeAll(wallEntityMatches);

                } catch (UnsupportedOperationException uoe){

                    errorReporter.fatalErrorReport(
                            "Unable to create illegal entities list",
                            uoe);
                }

                entityMatches.clear();
                zoneEntityMatches.clear();
                wallEntityMatches.clear();
                entityMatchCountMap.clear();
                zoneMatchCountMap.clear();
                wallMatchCountMap.clear();

            } else {

                return true;
            }
        }

        return false;
    }

    /**
     * Begin collision results analysis for collision tree results. These
     * results come from an entity and all of its children being evaluated for
     * collisions at the same time.
     *
     * Separate collisions into the following types:
     * TYPE_MODEL       (classification relationship matching only)
     * TYPE_ZONE        (floor)
     * TYPE_SEGMENT     (wall)
     *
     * @param collisionList Collision results for the specific entity
     * @param matches Specific entity in the tree of entities tested
     * @param classRelationship String[] of relationship names of current entity
     * @param classification String[] of classification names of current entity - used only if ignoreSameClass is true
     * @param childrenToIgnore ArrayList<Entity> children to remove from collision list
     * @param classificationToReplace String[] of classifications to replace
     * @param maxIndex Number of classRelationship indexes to check
     * @param vaporEntities Entity[] entities not yet in the scene to consider
     * @param ignoreSameClass If true collision objects with same
     * classification will be ignored
     * @param ignoreEntityIdList list of entity id's to ignore
     * @return True if ok, false if couldn't match valid collisions to categories
     */
    protected boolean performExtendedCollisionAnalysis(
            ArrayList<Entity> collisionList,
            ChildrenMatches matches,
            String[] classRelationship,
            String[] classification,
            ArrayList<Entity> childrenToIgnore,
            String[] classificationToReplace,
            int maxIndex,
            Entity[] vaporEntities,
            boolean ignoreSameClass,
            int[] ignoreEntityIdList){

        // Replace the collisionEntities list with the specific collision
        // results for the matched set
        collisionEntities.clear();
        collisionEntities.addAll(collisionList);

        boolean result = performCollisionAnalysis(
                classRelationship,
                classification,
                childrenToIgnore,
                classificationToReplace,
                maxIndex,
                vaporEntities,
                ignoreSameClass,
                ignoreEntityIdList);

        matches.entityMatches.clear();
        matches.zoneEntityMatches.clear();
        matches.wallEntityMatches.clear();
        matches.replaceEntityMatches.clear();
        matches.illegalEntities.clear();
        matches.entityMatchCountMap.clear();
        matches.zoneMatchCountMap.clear();
        matches.wallMatchCountMap.clear();

        matches.entityMatches.addAll(entityMatches);
        matches.zoneEntityMatches.addAll(zoneEntityMatches);
        matches.wallEntityMatches.addAll(wallEntityMatches);
        matches.replaceEntityMatches.addAll(replaceEntityMatches);
        matches.illegalEntities.addAll(illegalEntities);
        matches.entityMatchCountMap.putAll(entityMatchCountMap);
        matches.zoneMatchCountMap.putAll(zoneMatchCountMap);
        matches.wallMatchCountMap.putAll(wallMatchCountMap);

        return result;
    }



    /**
     * Helper to extract required rule properties from the entity and hand off
     * to illegal collision check.
     *
     * @param entity Entity to examine
     * @return True if there are illegal collisions, false otherwise
     */
    protected boolean hasIllegalCollisionHelper(
            Entity entity){

        String[] classRelationship = (String[]) entity.getProperty(
                Entity.DEFAULT_ENTITY_PROPERTIES,
                ChefX3DRuleProperties.RELATIONSHIP_CLASSIFICATION_PROP);

        int[] relationshipAmount = (int[]) entity.getProperty(
                Entity.DEFAULT_ENTITY_PROPERTIES,
                ChefX3DRuleProperties.RELATIONSHIP_AMOUNT_PROP);

        Enum[] relModifier =
            (Enum[])
            entity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_PROP);


        if(classRelationship == null ||
                relationshipAmount == null ||
                relModifier == null){

            return true;
        }

        boolean result =
            hasIllegalCollisions(
                    classRelationship,
                    relationshipAmount,
                    relModifier);

        return result;
    }

    /**
     * Helper to extract required rule properties from the entity and hand off
     * to illegal collision check.
     *
     * @param entity Entity to examine
     * @return True if there are illegal collisions, false otherwise
     */
    protected boolean hasIllegalCollisionExtendedHelper(){

        if(collisionEntitiesMap == null)
            return true;

        if(collisionEntitiesMap.isEmpty())
            return false;

        Object[] keyArray= collisionEntitiesMap.keySet().toArray();

//System.out.println("Collisions to check: " + keyArray.length);

        for(int i = 0 ; i<keyArray.length;i++) {

            Entity entity = (Entity)keyArray[i];
            String[] classRelationship = (String[]) entity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.RELATIONSHIP_CLASSIFICATION_PROP);

            int[] relationshipAmount = (int[]) entity.getProperty(
                    Entity.DEFAULT_ENTITY_PROPERTIES,
                    ChefX3DRuleProperties.RELATIONSHIP_AMOUNT_PROP);

            Enum[] relModifier =
                (Enum[])
                entity.getProperty(
                        Entity.DEFAULT_ENTITY_PROPERTIES,
                        ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_PROP);

//System.out.println("class: " + classRelationship + " relAmt: " + relationshipAmount + " relMod: " + relModifier);
            if(classRelationship == null ||
                    relationshipAmount == null ||
                    relModifier == null){

                return true;
            }

            ChildrenMatches match = matchesMap.get(entity);

            boolean result =
                hasIllegalCollisions(
                        match,
                        classRelationship,
                        relationshipAmount,
                        relModifier);

            if(result==true)
                return true;
        }
        return false;
    }

    /**
     * Makes sure the collisionEntitiesMap results are appropriate in that
     * there are results to examine. If there aren't any collision results for
     * an entity, it is required the None relationship is specified to allow
     * it to be legal.
     *
     * @return True if collision results exist, false otherwise
     */
    protected boolean legalZeroCollisionExtendedCheck() {

        if(collisionEntitiesMap.size() > 0){

            // clone the other properties
            Iterator<Map.Entry<Entity, ArrayList<Entity>>> collisionSet =
                collisionEntitiesMap.entrySet().iterator();

            while (collisionSet.hasNext()) {

                Map.Entry<Entity, ArrayList<Entity>> mapEntry =
                    collisionSet.next();

                Entity entity = mapEntry.getKey();

                ArrayList<Entity> collisionResults = mapEntry.getValue();

                if (collisionResults.size() < 1) {

                    // If the reserved class relationship of None is used then,
                    // we will allow this case.
                    String[] relClass =
                        (String[]) entity.getProperty(
                                Entity.DEFAULT_ENTITY_PROPERTIES,
                                ChefX3DRuleProperties.
                                RELATIONSHIP_CLASSIFICATION_PROP);

                    if(relClass != null) {

                        for(int i = 0; i < relClass.length; i++) {

                            if(relClass[i].equalsIgnoreCase(
                                    ChefX3DRuleProperties.
                                    RESERVED_NONE_RELATIONSHIP)) {

                                return true;
                            }
                        }
                    }

                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Checks if there are any illegal collisions.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return true if there are illegal collisions, false otherwise
     */
    protected boolean hasIllegalCollisions(
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){

        // Each legal collision check will return the index of the legal case
        // that was found or -1 for nothing to evaluate. If -2 is returned in
        // any of these cases that indicates the data provided did not result
        // in any matches and therefore should be handled appropriately.
//System.out.println("   In hasIllegalColl: ");
        int illegalZoneRes = hasLegalZoneCollisions(
                classRelationship,
                relationshipAmount,
                relModifier);

        int illegalSegRes = hasLegalSegmentCollisions(
                classRelationship,
                relationshipAmount,
                relModifier);

        int illegalModelRes = hasLegalModelCollisions(
                classRelationship,
                relationshipAmount,
                relModifier);

        int crossCategoryRes = checkCrossCategoryCollisions(
                classRelationship,
                relationshipAmount,
                relModifier);

//System.out.println("  cols: " + illegalZoneRes + " " + illegalSegRes + " " + illegalModelRes + " " + crossCategoryRes);

        // If cross category check comes back as valid, then we don't care
        // about anything else. If it doesn't we want to make sure the
        // straight up individual cases are valid, otherwise we do have
        // an illegal collision.
        if (crossCategoryRes > -1) {
            return false;
        }

        // Check individual cases as a backup.
        if(illegalZoneRes == -2 ||
                illegalSegRes == -2 ||
                illegalModelRes == -2){

            return true;

        } else if (crossCategoryRes == -2){

            // Cross category results is a special case since a single
            // relationship could be satisfied and yet this could come
            // back as -2 indicating no satisfied cross classification
            // reference is satisfied. Yes, classification and category
            // are used interchangeably here. If we have satisfied one
            // of the earlier cases, then we don't have to worry
            // about the cross category case. That is what we
            // evaluate here.
            if(illegalZoneRes >= 0){
                ;
            } else if (illegalSegRes >= 0){
                ;
            } else if (illegalModelRes >= 0){
                ;
            } else {
                return true;
            }
        } else if(illegalEntities.size() > 0) {

            // Immediately check for illegal collision matches
            return true;
        }

        return false;
    }

    /**
     * Determines if the zone collisions are all legal. If any are not legal
     * collisions, the check will return either -2 or -1 depending on the
     * issue.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return index of matching classification, otherwise -1 if nothing to
     * check, -2 if illegal collision found
     */
    protected int hasLegalZoneCollisions(
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){

        for(int i = 0; i < classRelationship.length; i++){

            // Check for : character, otherwise standard check
            if(classRelationship[i].contains(":")){

                // For proper analysis we cannot have multiple entries with
                // the same name in a relClass so clean it
                HashMap<String, Integer> cleanedClassRelationship =
                    cleanClassRelationship(classRelationship[i]);

                Object[] keys =
                    cleanedClassRelationship.keySet().toArray();

                String token;

                boolean matchesFound = true;

                for (int x = 0; x < keys.length; x++) {

                    token = (String) keys[x];
                    int amt = cleanedClassRelationship.get(token);

                    if (amt == 1) {
                        amt = relationshipAmount[i];
                    }

                    if(!legalAssociationNumber(
                        zoneMatchCountMap.get(token),
                        amt,
                        (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                        matchesFound = false;
                        break;
                    }
                }

                if(!matchesFound){
                    continue;
                }

                return i;

            } else if(legalAssociationNumber(
                        zoneMatchCountMap.get(classRelationship[i]),
                        relationshipAmount[i],
                        (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                return i;
            }
        }

        if(zoneMatchCountMap != null && zoneMatchCountMap.size() > 0){
            return -2;
        }

        return -1;
    }

    /**
     * Checks if there are any illegal collisions.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return true if there are illegal collisions, false otherwise
     */
    protected boolean hasIllegalCollisions(
            ChildrenMatches match,
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){
        int illegalZoneRes= 0;
        int illegalSegRes = 0;
        int illegalModelRes = 0;
        int crossCategoryRes = 0;
        // Each legal collision check will return the index of the legal case
        // that was found or -1 for nothing to evaluate. If -2 is returned in
        // any of these cases that indicates the data provided did not result
        // in any matches and therefore should be handled appropriately.
        if(match== null) {

            illegalZoneRes= hasLegalZoneCollisions(
                    classRelationship,
                    relationshipAmount,
                    relModifier);

            illegalSegRes = hasLegalSegmentCollisions(
                    classRelationship,
                    relationshipAmount,
                    relModifier);

            illegalModelRes = hasLegalModelCollisions(
                    classRelationship,
                    relationshipAmount,
                    relModifier);

            crossCategoryRes = checkCrossCategoryCollisions(
                    null,
                    null,
                    null,
                    classRelationship,
                    relationshipAmount,
                    relModifier);
        }else {

            illegalZoneRes= hasLegalCollisions(
                    match.zoneMatchCountMap,
                    classRelationship,
                    relationshipAmount,
                    relModifier);

            illegalSegRes = hasLegalCollisions(
                    match.wallMatchCountMap,
                    classRelationship,
                    relationshipAmount,
                    relModifier);

            illegalModelRes = hasLegalCollisions(
                    match.entityMatchCountMap,
                    classRelationship,
                    relationshipAmount,
                    relModifier);

            crossCategoryRes = checkCrossCategoryCollisions(
                    match.zoneMatchCountMap,
                    match.entityMatchCountMap,
                    match.wallMatchCountMap,
                    classRelationship,
                    relationshipAmount,
                    relModifier);

        }

        // If cross category check comes back as valid, then we don't care
        // about anything else. If it doesn't we want to make sure the
        // straight up individual cases are valid, otherwise we do have
        // an illegal collision.
        if (crossCategoryRes > -1) {
            return false;
        }

        if(illegalZoneRes == -2 ||
                illegalSegRes == -2 ||
                illegalModelRes == -2){

            return true;

        } else if (crossCategoryRes == -2){

            // Cross category results is a special case since a single
            // relationship could be satisfied and yet this could come
            // back as -2 indicating no satisfied cross classification
            // reference is satisfied. Yes, classification and category
            // are used interchangeably here. If we have satisfied one
            // of the earlier cases, then we don't have to worry
            // about the cross category case. That is what we
            // evaluate here.
            if(illegalZoneRes >= 0){
                ;
            } else if (illegalSegRes >= 0){
                ;
            } else if (illegalModelRes >= 0){
                ;
            } else {
                return true;
            }
        } else if(match == null) {
            if(illegalEntities.size() > 0) {


                //Immediately check for illegal collision matches
                return true;
            }
        }else {
            if(match.illegalEntities.size() > 0) {


                //Immediately check for illegal collision matches
                return true;
            }
        }

        return false;
    }


    /**
     * Determines if the segment collisions are all legal. If any are not legal
     * collisions, the check will return either -2 or -1 depending on the
     * issue.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return index of matching classification, otherwise -1 if not found,
     * -2 if illegal collision found
     */
    protected int hasLegalSegmentCollisions(
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){

        for(int i = 0; i < classRelationship.length; i++){

            // Check for : character, otherwise standard check
            if(classRelationship[i].contains(":")){

                // For proper analysis we cannot have multiple entries with
                // the same name in a relClass so clean it
                HashMap<String, Integer> cleanedClassRelationship =
                    cleanClassRelationship(classRelationship[i]);

                Object[] keys =
                    cleanedClassRelationship.keySet().toArray();

                String token;

                boolean matchesFound = true;

                for (int x = 0; x < keys.length; x++) {

                    token = (String) keys[x];
                    int amt = cleanedClassRelationship.get(token);

                    if (amt == 1) {
                        amt = relationshipAmount[i];
                    }

                    if(!legalAssociationNumber(
                        wallMatchCountMap.get(token),
                        amt,
                        (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                        matchesFound = false;
                        break;
                    }
                }

                if(!matchesFound){
                    continue;
                }

                return i;

            } else if(legalAssociationNumber(
                                wallMatchCountMap.get(classRelationship[i]),
                                relationshipAmount[i],
                                (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                            return i;
            }
        }

        if(wallMatchCountMap != null && wallMatchCountMap.size() > 0){
            return -2;
        }

        return -1;
    }


    /**
     * Determines if the zone collisions are all legal. If any are not legal
     * collisions, the check will return either -2 or -1 depending on the
     * issue.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return index of matching classification, otherwise -1 if nothing to
     * check, -2 if illegal collision found
     */
    protected int hasLegalCollisions(
            HashMap<String,Integer> countMap,
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){

        for(int i = 0; i < classRelationship.length; i++){

            // Check for : character, otherwise standard check
            if(classRelationship[i].contains(":")){

                // For proper analysis we cannot have multiple entries with
                // the same name in a relClass so clean it
                HashMap<String, Integer> cleanedClassRelationship =
                    cleanClassRelationship(classRelationship[i]);

                Object[] keys =
                    cleanedClassRelationship.keySet().toArray();

                String token;

                boolean matchesFound = true;

                for (int x = 0; x < keys.length; x++) {

                    token = (String) keys[x];
                    int amt = cleanedClassRelationship.get(token);

                    if (amt == 1) {
                        amt = relationshipAmount[i];
                    }


                    if(!legalAssociationNumber(
                        countMap.get(token),
                        amt,
                        (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                        matchesFound = false;
                        break;
                    }
                }

                if(!matchesFound){
                    continue;
                }

                return i;

            } else if(legalAssociationNumber(
                        countMap.get(classRelationship[i]),
                        relationshipAmount[i],
                        (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                return i;
            }
        }

        if(countMap != null && countMap.size() > 0){
            return -2;
        }

        return -1;
    }


    /**
     * Determines if the model collisions are all legal. If any are not legal
     * collisions, the check will return either -2 or -1 depending on the
     * issue.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return index of matching classification, otherwise -1 if not found
     * -2 if illegal collision found
     */
    protected int hasLegalModelCollisions(
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){

        for(int i = 0; i < classRelationship.length; i++){

            // Check for : character, otherwise standard check
            if(classRelationship[i].contains(":")){

                // For proper analysis we cannot have multiple entries with
                // the same name in a relClass so clean it
                HashMap<String, Integer> cleanedClassRelationship =
                    cleanClassRelationship(classRelationship[i]);

                Object[] keys =
                    cleanedClassRelationship.keySet().toArray();

                String token;

                boolean matchesFound = true;

                for (int x = 0; x < keys.length; x++) {

                    token = (String) keys[x];
                    int amt = cleanedClassRelationship.get(token);

                    if (amt == 1) {
                        amt = relationshipAmount[i];
                    }

                    if(!legalAssociationNumber(
                        entityMatchCountMap.get(token),
                        amt,
                        (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)
                        relModifier[i])){

                        matchesFound = false;
                        break;
                    }
                }

                if(!matchesFound){
                    continue;
                }

                return i;

            } else if(legalAssociationNumber(
                entityMatchCountMap.get(classRelationship[i]),
                relationshipAmount[i],
                (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)
                relModifier[i])){

                    return i;
            }

        }

        if(entityMatchCountMap != null && entityMatchCountMap.size() > 0){
            return -2;
        }

        return -1;
    }

    /**
     * Determines if the multiple collisions are all legal. If any are not legal
     * collisions, the check will return either -2 or -1 depending on the
     * issue.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return index of matching classification, otherwise -1 if not found,
     * -2 if illegal collision found
     */
    protected int checkCrossCategoryCollisions(
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){

        int iterateSize = Math.min(
                classRelationship.length,
                Math.min(relationshipAmount.length, relModifier.length));

        boolean containsJoiner = false;

        for(int i = 0; i < iterateSize; i++){

            // Check for : character only
            if(classRelationship[i].contains(":")){

                containsJoiner = true;

                // For proper analysis we cannot have multiple entries with
                // the same name in a relClass so clean it
                HashMap<String, Integer> cleanedClassRelationship =
                    cleanClassRelationship(classRelationship[i]);

                Object[] keys =
                    cleanedClassRelationship.keySet().toArray();

                String token;

                boolean matchesFound = true;

                for (int x = 0; x < keys.length; x++) {

                    token = (String) keys[x];
                    int amt = cleanedClassRelationship.get(token);

                    if (amt == 1) {
                        amt = relationshipAmount[i];
                    }

                    if(legalAssociationNumber(
                        zoneMatchCountMap.get(token),
                        amt,
                        (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                        continue;

                    } else if(legalAssociationNumber(
                            wallMatchCountMap.get(token),
                            amt,
                            (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                        continue;

                    } else if(legalAssociationNumber(
                            entityMatchCountMap.get(token),
                            amt,
                            (ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES)relModifier[i])){

                        continue;

                    } else {
                        matchesFound = false;
                        break;
                    }
                }

                if(matchesFound){
                    return i;
                }
            }
        }

        if(containsJoiner &&
                ((zoneMatchCountMap != null && zoneMatchCountMap.size() > 0) ||
                (wallMatchCountMap != null && wallMatchCountMap.size() > 0 ) ||
                (entityMatchCountMap != null &&
                        entityMatchCountMap.size() > 0))){

            return -2;
        }

        return -1;
    }

    /**
     * Determines if the multiple collisions are all legal. If any are not legal
     * collisions, the check will return either -2 or -1 depending on the
     * issue.
     *
     * @param classRelationship String[]
     * @param relationshipAmount int[]
     * @param relModifier Enum[]
     * @return index of matching classification, otherwise -1 if not found,
     * -2 if illegal collision found
     */
    protected int checkCrossCategoryCollisions(
            HashMap<String,Integer> zoneCountMap,
            HashMap<String,Integer> entityCountMap,
            HashMap<String,Integer> wallCountMap,
            String[] classRelationship,
            int[] relationshipAmount,
            Enum[] relModifier){

        if(zoneCountMap != null &&
                wallCountMap != null &&
                entityCountMap != null) {

            zoneMatchCountMap = zoneCountMap;
            wallMatchCountMap = wallCountMap;
            entityMatchCountMap = entityCountMap;
        }

        int result =
            checkCrossCategoryCollisions(
                    classRelationship,
                    relationshipAmount,
                    relModifier);

        return result;
    }

    /**
     * Check the requirements on the found relationship for the correct
     * number and modifier value.
     *
     * @param numCollisions Number of collisions found
     * @param relNumber Number of relationship collisions required
     * @param relModifier Modifier on relationship collisions required
     * @return boolean True if legal, false otherwise
     */
    protected boolean legalAssociationNumber(
            Integer numCollisions,
            int relNumber,
            ChefX3DRuleProperties.RELATIONSHIP_MODIFIER_VALUES relModifier){

        if(numCollisions == null){
            return false;
        }

        boolean legalAssociation = false;

        switch(relModifier){

            case LESS_THAN:
                if(numCollisions < relNumber){
                    legalAssociation = true;
                }
                break;

            case GREATER_THAN:
                if(numCollisions > relNumber){
                    legalAssociation = true;
                }
                break;

            case LESS_THAN_OR_EQUAL_TO:
                if(numCollisions <= relNumber){
                    legalAssociation = true;
                }
                break;

            case GREATER_THAN_OR_EQUAL_TO:
                if(numCollisions >= relNumber){
                    legalAssociation = true;
                }
                break;

            case EQUAL_TO:
                if(numCollisions == relNumber){
                    legalAssociation = true;
                }
                break;

            case NOT_EQUAL_TO:
                if(numCollisions != relNumber){
                    legalAssociation = true;
                }
                break;

            case NONE:
                legalAssociation = true;
                break;
        }

        return legalAssociation;
    }

    /**
     * Checks the child object bounds against the parent bounds to see
     * if it is within the bounds of the parent. Returns true if it is
     * within bounds false otherwise.
     *
     * @param childEntity Entity
     * @param parentEntity Entity
     * @return True if in bounds, false otherwise
     */
    protected boolean performParentBoundsCheck(
            Entity childEntity,
            Entity parentEntity){

        if (parentEntity instanceof BasePositionableEntity &&
                childEntity instanceof BasePositionableEntity){

            BasePositionableEntity parentBPE =
                (BasePositionableEntity) parentEntity;

            BasePositionableEntity childBPE =
                (BasePositionableEntity) childEntity;

            // Get the parent bounds and pos
            double[] parentPos = new double[3];
            float[] parentBounds = new float[6];

            parentBPE.getPosition(parentPos);
            parentBPE.getBounds(parentBounds);

            // Create the 4 parent coordinates
            double[] topLeft = {
                    parentPos[0] + parentBounds[0],
                    parentPos[1] + parentBounds[3],
                    0.0};

            double[] bottomLeft = {
                    parentPos[0] + parentBounds[0],
                    parentPos[1] + parentBounds[2],
                    0.0};

            double[] bottomRight = {
                    parentPos[0] + parentBounds[1],
                    parentPos[1] + parentBounds[2],
                    0.0};

            double[] topRight = {
                    parentPos[0] + parentBounds[1],
                    parentPos[1] + parentBounds[3],
                    0.0};

            // Get the child bounds and pos
            double[] pos = new double[3];
            float[] bounds = new float[6];

            childBPE.getBounds(bounds);
            childBPE.getPosition(pos);

            pos[2] = 0.0;

            /*
             * Create the 4 coordinates to test (top left, bottom left,
             * bottom right, top right) based on the object position and
             * bounds.
             */
            double[] testCoords = {
                    pos[0] + bounds[0],
                    pos[1] + bounds[3],
                    pos[2],

                    pos[0] + bounds[0],
                    pos[1] + bounds[2],
                    pos[2],

                    pos[0] + bounds[1],
                    pos[1] + bounds[2],
                    pos[2],

                    pos[0] + bounds[1],
                    pos[1] + bounds[3],
                    pos[2]};

            // Perform polygon angle summation to determine if inside or outside wall
            Vector3d topLeftVector;
            Vector3d bottomLeftVector;
            Vector3d bottomRightVector;
            Vector3d topRightVector;

            for(int i = 0; i < 4; i++){

                topLeftVector = new Vector3d(
                        topLeft[0] - testCoords[i*3],
                        topLeft[1] - testCoords[i*3+1],
                        topLeft[2] - testCoords[i*3+2]);

                bottomLeftVector = new Vector3d(
                        bottomLeft[0] - testCoords[i*3],
                        bottomLeft[1] - testCoords[i*3+1],
                        bottomLeft[2] - testCoords[i*3+2]);

                bottomRightVector = new Vector3d(
                        bottomRight[0] - testCoords[i*3],
                        bottomRight[1] - testCoords[i*3+1],
                        bottomRight[2] - testCoords[i*3+2]);

                topRightVector = new Vector3d(
                        topRight[0] - testCoords[i*3],
                        topRight[1] - testCoords[i*3+1],
                        topRight[2] - testCoords[i*3+2]);

                double radians = 0.0;
                radians += topLeftVector.angle(bottomLeftVector);
                radians += bottomLeftVector.angle(bottomRightVector);
                radians += bottomRightVector.angle(topRightVector);
                radians += topRightVector.angle(topLeftVector);

                if(Math.abs((2*Math.PI)-radians) > 0.0001){
                    return false;
                }
            }

        }

        return true;
    }

    /**
     * Checks the child object against the segment bounds to see
     * if it is within the bounds of the segment. Returns true if it is
     * within bounds false otherwise.
     *
     * @param model WorldModel
     * @param childEntity Entity
     * @param parentEntityID entity ID of childEntity parent
     * @param leftVertexHeight Float if null, value found will be used
     * @param rightVertexHeight Float if null, value found will be used
     * @param rotation float[] rotation of the entity
     * @param command The command being executed
     * @return True if in bounds, false otherwise
     */
    protected boolean performSegmentBoundsCheck(
            WorldModel model,
            Entity childEntity,
            int parentEntityID,
            Float leftVertexHeight,
            Float rightVertexHeight,
            float[] rotation,
            Command command){

        Entity parentEntity = null;
        int parentID = parentEntityID;

        double[] parentPosSum = new double[] {0.0, 0.0, 0.0};

        while (!(parentEntity instanceof SegmentEntity)){

            parentEntity = model.getEntity(parentID);

            if (parentEntity instanceof SegmentEntity){

                SegmentEntity wallEntity = (SegmentEntity)parentEntity;

                // Get vectors and extract positions
                VertexEntity startVertexEntity = wallEntity.getStartVertexEntity();
                VertexEntity endVertexEntity = wallEntity.getEndVertexEntity();

                double[] startVertexPos = new double[3];
                double[] endVertexPos = new double[3];

                startVertexEntity.getPosition(startVertexPos);
                endVertexEntity.getPosition(endVertexPos);

                Vector3d wallVec = new Vector3d(
                        endVertexPos[0] - startVertexPos[0],
                        endVertexPos[1] - startVertexPos[1],
                        0.0);

                double wallLength = wallVec.length();

                // Create the 4 wall coordinates
                double topLeftHeight = 0.0;
                double topRightHeight = 0.0;

                if(leftVertexHeight != null){
                    topLeftHeight = leftVertexHeight;
                } else {
                    topLeftHeight = startVertexEntity.getHeight();
                }

                if(rightVertexHeight != null){
                    topRightHeight = rightVertexHeight;
                } else {
                    topRightHeight = endVertexEntity.getHeight();
                }

                double[] topLeft = {
                        0.0,
                        topLeftHeight,
                        0.0};

                double[] bottomLeft = {
                        0.0,
                        0.0,
                        0.0};

                double[] bottomRight = {
                        wallLength,
                        0.0,
                        0.0};

                double[] topRight = {
                        wallLength,
                        topRightHeight,
                        0.0};

                // need to base the check on the final bounds not the current bounds.
                // default to current scale and position for most cases
                float[] scale = new float[3];
                double[] pos = new double[3];
                if (command instanceof ScaleEntityCommand) {
                    ((ScaleEntityCommand)command).getNewScale(scale);
                    ((ScaleEntityCommand)command).getNewPosition(pos);
                } else {
                    ((PositionableEntity)childEntity).getScale(scale);
                    ((PositionableEntity)childEntity).getPosition(pos);
                }

                // Get the entity bounds
                float[] bounds = new float[6];
                calculateBounds((PositionableEntity)childEntity, scale, bounds);

                Boolean spanObject = (Boolean) childEntity.getProperty(
                        Entity.DEFAULT_ENTITY_PROPERTIES,
                        ChefX3DRuleProperties.SPAN_OBJECT_PROP);
                if (spanObject != null && spanObject) {
                    bounds[0] += SPAN_OVERLAP_THRESHOLD;
                    bounds[1] -= SPAN_OVERLAP_THRESHOLD;
                }

                // Get the entity position, flatten to xy plane
                pos[0] = parentPosSum[0] + pos[0];
                pos[1] = parentPosSum[1] + pos[1];
                //pos[2] = parentPosSum[2] + pos[2];
                pos[2] = 0.0;

                Vector3f topLeftVec = new Vector3f(
                        (float) bounds[0],
                        (float) bounds[3],
                        (float) 0.0);
                Vector3f bottomLeftVec = new Vector3f(
                        (float)bounds[0],
                        (float)bounds[2],
                        (float)0.0);
                Vector3f bottomRightVec = new Vector3f(
                        (float)bounds[1],
                        (float)bounds[2],
                        (float)0.0);
                Vector3f topRightVec = new Vector3f(
                        (float)bounds[1],
                        (float)bounds[3],
                        (float)0.0);

                // Consider rotation in bounds check
                Matrix4f mat = new Matrix4f();
                mat.setIdentity();
                mat.setRotation(new AxisAngle4f(rotation));
                mat.transform(topLeftVec);
                mat.transform(bottomLeftVec);
                mat.transform(bottomRightVec);
                mat.transform(topRightVec);

                /*
                 * Create the 4 coordinates to test (top left, bottom left,
                 * bottom right, top right) based on the object position and
                 * bounds.
                 */
                double[] testCoords = {
                        pos[0]+topLeftVec.x,
                        pos[1]+topLeftVec.y,
                        0.0,

                        pos[0]+bottomLeftVec.x,
                        pos[1]+bottomLeftVec.y,
                        0.0,

                        pos[0]+bottomRightVec.x,
                        pos[1]+bottomRightVec.y,
                        0.0,

                        pos[0]+topRightVec.x,
                        pos[1]+topRightVec.y,
                        0.0};

                // Perform polygon angle summation to determine if inside or outside wall
                Vector3d topLeftVector;
                Vector3d bottomLeftVector;
                Vector3d bottomRightVector;
                Vector3d topRightVector;

                for(int i = 0; i < 4; i++){

                    topLeftVector = new Vector3d(
                            topLeft[0] - testCoords[i*3],
                            topLeft[1] - testCoords[i*3+1],
                            topLeft[2] - testCoords[i*3+2]);

                    bottomLeftVector = new Vector3d(
                            bottomLeft[0] - testCoords[i*3],
                            bottomLeft[1] - testCoords[i*3+1],
                            bottomLeft[2] - testCoords[i*3+2]);

                    bottomRightVector = new Vector3d(
                            bottomRight[0] - testCoords[i*3],
                            bottomRight[1] - testCoords[i*3+1],
                            bottomRight[2] - testCoords[i*3+2]);

                    topRightVector = new Vector3d(
                            topRight[0] - testCoords[i*3],
                            topRight[1] - testCoords[i*3+1],
                            topRight[2] - testCoords[i*3+2]);

                    double radians = 0.0;
                    radians += topLeftVector.angle(bottomLeftVector);
                    radians += bottomLeftVector.angle(bottomRightVector);
                    radians += bottomRightVector.angle(topRightVector);
                    radians += topRightVector.angle(topLeftVector);

                    double result = Math.abs((2*Math.PI)-radians);

                    if(result > ANGLE_CHECK_THRESHOLD){
                        return false;
                    }
                }

            }

            /*
             * Get parent position to build up transform
             */
            if(parentEntity instanceof BasePositionableEntity){

                double[] tempPos = new double[3];
                ((BasePositionableEntity)parentEntity).getPosition(tempPos);

                parentPosSum[0] = parentPosSum[0] + tempPos[0];
                parentPosSum[1] = parentPosSum[1] + tempPos[1];
                parentPosSum[2] = parentPosSum[2] + tempPos[2];
            }

            /*
             * Get next parent
             */
            if(parentEntity instanceof Entity){
                parentID = parentEntity.getParentEntityID();
            } else {
                break;
            }

        }

        return true;
    }

    /**
     * Get the simple tool matching the name.
     *
     * @param name Name of tool to retrieve
     * @return SimpleTool or null if not found
     */
    protected SimpleTool getSimpleToolByName(String id){

        SimpleTool tool =
            (SimpleTool) catalogManager.findTool(id);

        return tool;
    }

    /**
     * Get the first encountered ZoneEntity parent for the given entity.
     *
     * @param model WorldModel to look up entities by ID
     * @param entity Entity to start search with
     * @return Entity parent of type ZoneEntity or null if not found
     */
    protected Entity getParentZoneEntity(WorldModel model, Entity entity){

        if (entity instanceof SegmentEntity ||
                entity instanceof ZoneEntity) {

            return entity;
        }

        int parentEntityID = entity.getParentEntityID();
        Entity parentEntity = model.getEntity(parentEntityID);

        while(!(parentEntity instanceof ZoneEntity)){

            if(parentEntity instanceof Entity){
                parentEntityID = parentEntity.getParentEntityID();
                parentEntity = model.getEntity(parentEntityID);
            } else {
                return null;
            }
        }

        return parentEntity;
    }

    /**
     * Get all neighbors in the positive x direction from the given entity.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getPositiveXNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        NearestNeighborMeasurement.POS_X,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the positive x direction that match the
     * product name or classification type of that product.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param name String classification type name
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getPositiveXNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            String name,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        name,
                        NearestNeighborMeasurement.POS_X,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the negative x direction from the given entity.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getNegativeXNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        NearestNeighborMeasurement.NEG_X,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the negative x direction that match the
     * product name or classification type of that product.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param name String classification type name
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getNegativeXNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            String name,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        name,
                        NearestNeighborMeasurement.NEG_X,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the positive y direction from the given entity.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getPositiveYNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        NearestNeighborMeasurement.POS_Y,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the positive y direction that match the
     * product name or classification type of that product.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param name String classification type name
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getPositiveYNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            String name,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        name,
                        NearestNeighborMeasurement.POS_Y,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the positive y direction from the given entity.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getNegativeYNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        NearestNeighborMeasurement.NEG_Y,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the negative y direction that match the
     * product name or classification type of that product.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param name String classification type name
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getNegativeYNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            String name,
            float[] boundsAdj){

        return(
                getNeighbors(
                        model,
                        evalEntity,
                        name,
                        NearestNeighborMeasurement.NEG_Y,
                        boundsAdj));
    }

    /**
     * Get all neighbors in the specified direction from the given entity.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param direction The direction to check
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            int direction,
            float[] boundsAdj){

        Entity zoneEntity = getParentZoneEntity(
                model,
                evalEntity);

        if (zoneEntity != null) {

            return nearestNeighbor.nearestNeighbors(
                    model,
                    zoneEntity,
                    evalEntity,
                    direction,
                    boundsAdj);

        } else {
            return null;
        }
    }

    /**
     * Get all neighbors in the specified direction that match the
     * product name or classification type of that product.
     *
     * @param model WorldModel to look up other entities
     * @param evalEntity PositionableEntity to perform neighbor check on
     * @param name String classification type name
     * @param direction The direction to check
     * @param boundsAdj x,y,z axis additional bounds values to consider,
     * can be null if no adjustment to the entity bounds is needed
     * @return ArrayList<Entity> of neighbors or null if unable to check
     */
    protected ArrayList<Entity> getNeighbors(
            WorldModel model,
            PositionableEntity evalEntity,
            String name,
            int direction,
            float[] boundsAdj){

        ArrayList<Entity> neighbors = getNeighbors(
                model,
                evalEntity,
                direction,
                boundsAdj);

        if (neighbors != null) {

            String[] classifications = (String[]) evalEntity.getProperty(
                Entity.DEFAULT_ENTITY_PROPERTIES,
                ChefX3DRuleProperties.CLASSIFICATION_PROP);

            for(int i = neighbors.size()-1; i >= 0; i--){

                String tmpName = neighbors.get(i).getName();

                if(!tmpName.equals(name)){

                    String[] tmpClass = (String[]) neighbors.get(i).getProperty(
                        Entity.DEFAULT_ENTITY_PROPERTIES,
                        ChefX3DRuleProperties.CLASSIFICATION_PROP);

                    if(tmpClass != null){

                        boolean classMatchFound = false;

                        for(int w = 0; w < classifications.length; w++){

                            for(int x = 0; x < tmpClass.length; x++){

                                if(tmpClass[x].equals(classifications[w])){

                                    classMatchFound = true;
                                    break;
                                }
                            }

                            if(classMatchFound){
                                break;
                            }
                        }

                        if(classMatchFound){
                            continue;
                        }
                    }

                    neighbors.remove(i);
                }
            }
        }
        return neighbors;
    }

    /**
     * Get the position of an entity relative to the zone.
     *
     * @author Eric Fickenscher
     * @param model reference to the WorldModel
     * @param entity Entity of which we want to know the relative position
     * @return double[] xyz pos relative to relativeEntity
     */
    protected double[] getPositionRelativeToZone(
            WorldModel model,
            Entity entity){

        return getRelativePosition(
            model,
            entity,
            TransformUtils.findZoneEntity(model, entity),
            false);
    }


    /**
     *
     * Get the position of an entity relative to a specific parent.
     *
     * @param model WorldModel
     * @param startEntity Starting entity to build up position data from
     * @param relativeEntity Entity to stop building position data at
     * @param useStartPosition Set true if position should be derived from
     * start positions
     * @return double[] xyz pos relative to relativeEntity
     */
    protected double[] getRelativePosition(
            WorldModel model,
            Entity startEntity,
            Entity relativeEntity,
            boolean useStartPosition){

        double[] posTotal = new double[3];
        double[] tmpPos = new double[3];

        int parentEntityID = startEntity.getParentEntityID();
        Entity parentEntity = model.getEntity(parentEntityID);

        if(!(parentEntity instanceof PositionableEntity)){
            return posTotal;
        }

        if(useStartPosition){
            ((PositionableEntity)startEntity).getStartingPosition(posTotal);
        } else {
            ((PositionableEntity)startEntity).getPosition(posTotal);
        }

        while(!(parentEntity instanceof ZoneEntity)){

            if(parentEntity instanceof PositionableEntity){

                if(useStartPosition){
                    ((PositionableEntity)startEntity).getStartingPosition(
                            tmpPos);
                } else {
                    ((PositionableEntity)parentEntity).getPosition(tmpPos);
                }

                posTotal[0] = posTotal[0] + tmpPos[0];
                posTotal[1] = posTotal[1] + tmpPos[1];
                posTotal[2] = posTotal[2] + tmpPos[2];

                parentEntityID = parentEntity.getParentEntityID();
                parentEntity = model.getEntity(parentEntityID);

            } else {

                return null;
            }
        }

        return posTotal;
    }

    /**
     * Produces double[] xyz values of axis specific distance between
     * firstEntity and secondEntity. Calculated as firstEntity - secondEntity.
     *
     * @param model WorldModel
     * @param firstEntity First Entity
     * @param secondEntity Second Entity
     * @return double[] xyz order distance values, or null if cannot compute
     */
    protected double[] getDistanceBetweenEntities(WorldModel model, Entity firstEntity, Entity secondEntity){

        Entity firstEntityZoneParent = getParentZoneEntity(model, firstEntity);
        Entity secondEntityZoneParent = getParentZoneEntity(model, secondEntity);

        /*
         * If these do not share the same zone entity, we cannot compute
         */
        if(firstEntityZoneParent.getEntityID() !=
            secondEntityZoneParent.getEntityID()){

            return null;
        }

        double[] firstRelPos =
            getRelativePosition(model, firstEntity, firstEntityZoneParent, false);

        double[] secondRelPos =
            getRelativePosition(model, secondEntity, secondEntityZoneParent, false);

        double[] distanceVals = new double[3];

        distanceVals[0] = firstRelPos[0] - secondRelPos[0];
        distanceVals[1] = firstRelPos[1] - secondRelPos[1];
        distanceVals[2] = firstRelPos[2] - secondRelPos[2];

        return distanceVals;
    }

    /**
     * Add a command to the newlyIssuedCommands ArrayList
     *
     * @param command Command to add
     */
    protected void addNewlyIssuedCommand(Command command){

        newlyIssuedCommands.add(command);
    }

    /**
     * Add a list of commands to the newlyIssuedCommands ArrayLsit
     * @param cmdList ArrayList<Command> of commands
     */
    protected void addNewlyIssuedCommand(ArrayList<Command> cmdList){

        newlyIssuedCommands.addAll(cmdList);
    }

    /**
     * Sort a list of entities in descending position order.
     *
     * @param originalList List of entities to sort
     * @param axis Axis to do comparisons along
     * @return List of entities or null if there was a problem
     */
    protected ArrayList<Entity> sortDescendingPosValueOrder(
            ArrayList<Entity> originalList,
            ChefX3DRuleProperties.TARGET_ADJUSTMENT_AXIS axis){

        // Performs insertion sort algorithm to build up the sorted list to
        // return.
        ArrayList<Entity> newList = new ArrayList<Entity>();

        double[] curPos = new double[3];
        double[] sortedEntityPos = new double[3];
        PositionableEntity curEntity = null;
        PositionableEntity sortedEntity = null;

        for(int i = 0; i < originalList.size(); i++) {

            // Extract the next entity to sort and get its position
            try {

                curEntity = (PositionableEntity)originalList.get(i);
                curEntity.getPosition(curPos);

            } catch(ClassCastException cce) {
                System.out.println("CCE caught");
                errorReporter.errorReport(
                        CLASS_CAST_EXCEPTION_MSG,
                        cce);

                return null;
            }

            // Perform insertion operation at correct level
            int index = 0;

            do {

                // Handle belongs at bottom case
                if(index >= newList.size()) {

                    newList.add(curEntity);
                    break;

                } else {

                    // Compare check
                    sortedEntity = (PositionableEntity) newList.get(index);
                    sortedEntity.getPosition(sortedEntityPos);
                    boolean insertBefore = false;

                    switch(axis) {

                        case XAXIS:
                            if(curPos[0] > sortedEntityPos[0]) {
                                insertBefore = true;
                            }
                            break;

                        case YAXIS:
                            if(curPos[1] > sortedEntityPos[1]) {
                                insertBefore = true;
                            }
                            break;

                        case ZAXIS:
                            if(curPos[2] > sortedEntityPos[2]) {
                                insertBefore = true;
                            }
                            break;
                    }

                    if(insertBefore) {

                        newList.add(index, curEntity);
                        break;
                    }
                }

                index++;

            } while (index < newList.size());

            if(index >= newList.size()){

                newList.add(curEntity);
            }
        }


        return newList;
    }

    /**
     * Check a list of collisions for dependency on the entityIdsToIgnore list.
     * Will check a list of entities to see if any require a specific collision
     * that does not exist, either because it's no longer where it was expected
     * in the scene, or it has been removed in the entityIdsToIgnore list. Can
     * optionally set the ignoreAutoAdded flag to ignore skip Entities in the
     * collisionList that are auto added entities.
     *
     * Method automatically removes all segment and zone entities from collisionList.
     *
     * @param model WorldModel to reference
     * @param modelCollisionList List of entities to check as dependents
     * @param entityIdsToIgnore Entity id's to ignore
     * @param ignoreAutoAdded True to ignore auto added products in check
     * @return False if there are no dependencies, true otherwise
     */
    protected boolean hasDependantProductAttached(
            WorldModel model,
            ArrayList<Entity> collisionList,
            int[] entityIdsToIgnore,
            boolean ignoreAutoAdded){

        // Copy the list over so that future collision checks
        // don't accidently overwrite the original data.
        ArrayList<Entity> modelCollisionList =
            new ArrayList<Entity>(collisionList);

        // Remove any semgent and zone entities from list. Only operate on
        // type model
        for(int i = (modelCollisionList.size()-1); i >= 0; i--){

            if (modelCollisionList.get(i).getType() != Entity.TYPE_MODEL) {
                modelCollisionList.remove(i);
            }
        }

        // See if removing the entity from collision set of all collision
        // entities discovered would cause them to have illegal collisions.
        // If it would, then it has dependent products attached.

        for(int i = 0; i < modelCollisionList.size(); i++){

            int transID = model.issueTransactionID();
            Entity tmpEntity = modelCollisionList.get(i);
            double[] pos = new double[3];

            // If flagged, ignore auto added products
            if(ignoreAutoAdded){

                Boolean isAutoAddProduct =
                    (Boolean) tmpEntity.getProperty(
                            Entity.DEFAULT_ENTITY_PROPERTIES,
                            ChefX3DRuleProperties.IS_AUTO_ADD_PRODUCT);

                if(isAutoAddProduct != null && isAutoAddProduct == true){
                    continue;
                }
            }

            // Can't operate on product without accessable position data
            if(!(tmpEntity instanceof PositionableEntity)){

                return true;
            }

            ((PositionableEntity)tmpEntity).getPosition(pos);

            MoveEntityCommand tmpMvCmd =
                new MoveEntityCommand(
                        model,
                        transID,
                        tmpEntity.getEntityID(),
                        pos,
                        pos);

            performCollisionCheck(tmpMvCmd);

            performCollisionAnalysisHelper(
                    tmpEntity,
                    null,
                    false,
                    entityIdsToIgnore,
                    true);

            // If there are illegal collisions without the specified entity id
            // considered in the collision list then we have a dependancy we
            // must respect, so return true.
            if(hasIllegalCollisionHelper(tmpEntity)){

                return true;
            }
        }

        return false;
    }

    /**
     * Check to see if the entity should not be moved because of collisions
     * that are dependent on it.
     *
     * @param model WorldModel to reference
     * @param entity Entity to check for collision dependencies on
     * @return True if other entities are dependent on it, false otherwise
     */
    protected boolean isDependantFixedEntity(
            WorldModel model,
            PositionableEntity entity){

        int transID = model.issueTransactionID();

        double[] pos = new double[3];

        entity.getPosition(pos);

        MoveEntityCommand mvCmd =
            new MoveEntityCommand(
                    model,
                    transID,
                    entity.getEntityID(),
                    pos,
                    pos);

        performCollisionCheck(mvCmd);

        ArrayList<Entity> dependentCheckSet =
            new ArrayList<Entity>(collisionEntities);

        for (int i = 0; i < dependentCheckSet.size(); i++) {

            if (dependentCheckSet.get(i).getEntityID() ==
                entity.getParentEntityID()) {

                dependentCheckSet.remove(i);
                break;
            }
        }

        boolean result =
            hasDependantProductAttached(
                    model,
                    dependentCheckSet,
                    new int[] {entity.getEntityID()},
                    false);

        return result;
    }

    //--------------------------------------------------------------------
    // Private methods
    //--------------------------------------------------------------------


    /**
     * Add an entity to the entityMatches list and classificationMatchCountMap
     *
     * @param entity Entity
     * @param classRelationship String
     */
    private void addMatch(ArrayList<Entity> match, HashMap<String,Integer> matchCount, Entity entity, String classRelationship){

        match.add(entity);

        Integer count = matchCount.get(classRelationship);

        if(count == null){
            matchCount.put(classRelationship, 1);
        } else {
            count++;
            matchCount.put(classRelationship, count);
        }
    }


    /**
     * Add an entity to the entityMatches list and classificationMatchCountMap
     *
     * @param entity Entity
     * @param classRelationship String
     */
    private void addModelMatch(Entity entity, String classRelationship){

        entityMatches.add(entity);

        Integer count = entityMatchCountMap.get(classRelationship);

        if(count == null){
            entityMatchCountMap.put(classRelationship, 1);
        } else {
            count++;
            entityMatchCountMap.put(classRelationship, count);
        }
    }

    /**
     * Add an entity to the zoneEntityMatches list
     *
     * @param entity
     */
    private void addZoneMatch(Entity entity, String classRelationship){

        zoneEntityMatches.add(entity);

        Integer count = zoneMatchCountMap.get(classRelationship);

        if(count == null){
            zoneMatchCountMap.put(classRelationship, 1);
        } else {
            count++;
            zoneMatchCountMap.put(classRelationship, count);
        }
    }

    /**
     * Add an entity to the wallEntityMatches list
     *
     * @param entity
     */
    private void addSegmentMatch(Entity entity, String classRelationship){

        wallEntityMatches.add(entity);

        Integer count = wallMatchCountMap.get(classRelationship);

        if(count == null){
            wallMatchCountMap.put(classRelationship, 1);
        } else {
            count++;
            wallMatchCountMap.put(classRelationship, count);
        }
    }

    /**
     * Add an entity to the replaceEntityMatches list
     *
     * @param entity
     */
    private void addReplaceMatch(Entity entity){

        replaceEntityMatches.add(entity);
    }

    /**
     * Clean up the relClass into a representative HashMap of the each
     * expressed relationship with duplicates accounted for in the Integer
     * value of the HashMap. When evaluating the relAmt, if the Integer
     * quantity stored in the HashMap is > 1, then it is used in place
     * of the relAmt specified.
     *
     * @param relClass String to parse
     * @return HashMap<String, Integer> or null if relClass doesn't contain :
     */
    private HashMap<String, Integer> cleanClassRelationship(String relClass) {

        if (!relClass.contains(":")) {
            return null;
        }

        HashMap<String, Integer> cleanedResults =
            new HashMap<String, Integer>();

        StringTokenizer st = new StringTokenizer(relClass, ":");
        String token;

        while(st.hasMoreTokens()){

            token = st.nextToken();

            Integer count = cleanedResults.get(token);

            if (count == null) {
                cleanedResults.put(token, 1);
            } else {
                count++;
                cleanedResults.put(token, count);
            }
        }

        return cleanedResults;
    }
}
